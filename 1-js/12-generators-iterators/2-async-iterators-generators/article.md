
# ასინქრონული იტერაცია და გენერატორები

ასინქრონული იტერაცია საშუალებას გვაძლევს გადავუყვეთ ასინქრონულად მიღებულ მონაცემს. მაგალითად, როდესაც ქსელიდან ნაწილ-ნაწილ ვიწერთ რაიმეს. ასინქრონული გენერატორები ამ ყველაფერს იმპლემენტაციას უფრო კომფორტულს ხდის.

მოდი ჯერ მარტივი მაგალითი ვნახოთ, გავიგოთ სინტაქსი როგორია და შემდეგ რეალური მაგალითი განვიხილოთ.

## გავიხსენოთ იტერატორები

მოდი გავიხსენოთ იტერატორების თავი.

ანუ გვაქვს ობიექტი, როგირიცაა `range`:
```js
let range = {
  from: 1,
  to: 5
};
```

...და გვინდა გამოვიყენოთ `for..of` ციკლი, როგორიცაა `for(value of range)`, რომ დავითრიოთ მნიშვნელობები `1`-დან `5`-მდე.

სხვა სიტყვებით, ჩვენ გვინდა *იტერაციის უნარი* დავუმატოთ ობიექტს.

ამის მისაღწევად საჭიროა სპეციალური მეთოდის გამოყენება `Symbol.iterator`:

- ამ მეთოდს გამოიძახებს `for..of` ციკლის დასაწყისში გამოიძახებს, და მან უნდა დააბრუნოს ობიექტი `next` მეთოდით.
- ყოველ იტერაციაზე, `next()` მეთოდი შემდეგი მნიშვნელობის მისაღებად გამოიძახება.
- `next()`-მდა უნდა დააბრუნოს მნიშვნელობა ფორმით `{done: true/false, value:<ციკლის მნიშვნელობა>}`, სადაც `done:true` ციკლის დასასრულს ნიშნავს.

ქვემოთ მოცემულია იტერირებადი `range`-ის იმპლემენტაცია:

```js run
let range = {
  from: 1,
  to: 5,

*!*
  [Symbol.iterator]() { // გამოიძახება მხოლოდ ერთხელ, for..of-ის დასაწყისში
*/!*
    return {
      current: this.from,
      last: this.to,

*!*
      next() { // გამოიძახება ყოველ იტერაციაზე შემდეგი მნიშვნელობის დასათრევად
*/!*
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for(let value of range) {
  alert(value); // 1 then 2, then 3, then 4, then 5
}
```

თუ რამე გაუგებარია, ეწვიეთ თავს [იტერატორები](info:iterable), ჩვეულებრივ იტერატორებზე ინფორმაციის მისაღებად.

## ასინქრონული იტერატორები

ასინქრონული იტერაცია საჭიროა როდესაც მნიშვნელობებს ასინქრონულად ვიღებთ: `setTimeout`-ის ან მაგდაგვარი შემფერხებლის შემდეგ.

ყველაზე ხშირი შემთხვევაა როდესაც ობიექტი ქსელს რექუესთს გაუგზავნის რომ შემდეგი მნიშვნელობა მიიღოს, ცოტა ხანში რეალურ მაგალითსაც განვიხილავთ.

იმისათვის რომ ობიექტი ასინქრონულად იტერირებადი ვაქციოთ, უნდა:

1. გამოვიყენოთ `Symbol.asyncIterator` `Symbol.iterator`-ის მაგივრად.
2. `next()` მეთოდმა უნდა დააბრუნოს "დაპირება" (promise, და მეც "ფრომისს" გამოვიყენებ), რათა შემდეგი მნიშვნელობით შეივსოს.
    - `async` ქივორდი მიხედავს ამ სიტუაციას, შეგვიძლია პირდაპირ `async next()` გამოვიყენოთ.
3. ასეთ ობიექტს რომ გადავუყვეთ, უნდა გამოვიყენოთ `for await (let item of iterable)` ციკლი.
    - ყურადღება მიაქციეთ `await` სიტყვას.

მოდი დასაწყისისთვის შევქმნათ წინა `range`-ის მაგვარი ობიექტი, მაგრამ ამჯერაც ის დააბრუნებს ასინქრონულ მნიშვნელობებს ყოველ ერთ წამში.

მხოლოდ რამდენიმე ცვლილების შეტანა მოგვიწევს.

```js run
let range = {
  from: 1,
  to: 5,

*!*
  [Symbol.asyncIterator]() { // (1)
*/!*
    return {
      current: this.from,
      last: this.to,

*!*
      async next() { // (2)
*/!*

*!*
        // დააკვირდით, ჩვენ შეგვიძლია "await" გამოვიყენოთ async next-ში:
        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)
*/!*

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {

*!*
  for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
  }
*/!*

})()
```

როგორცე ხედავთ, იგივე სტრუქტურა აქვს როგორც ჩვეულებრივ იტერატორს:

1. იმისათვის რომ ობიექტი გავხადოთ ასინქრონულად იტერირებადი, მას უნდა ჰქონდეს მეთOდი `Symbol.asyncIterator` `(1)`.
2. ამ მეთოდმა უნდა დააბრუნოს ობიექტი `async next()` მეთოდით `(2)`.
3. `next()` მეთოდი არაა სავალდებულო იყოს `async`, ის შეიძლება იყოს ჩვეულებრივი მეთოდი რომელიც აბრუნებს ფრომისს, მაგრამ `async` საშუალებას გვაძლევს `await`-ის გამოყენებას და ამიტომ უფრო კომფორტულია. `(3)` აქ ჩვენ უბრალოდ 1 წამი ვაფერხებთ.
4. იტერაციის ჩვენ ვიყენებთ `for await (let value of range)` `(4)`, არ დაგავიწყდეთ "await"-ის დამატება "for"-ის შემდეგ. ის იძახებს `range[Symbol.asyncIterator]()`-ს ერთხელ, და შემდეგ `next()`-ს მომდევნო მნიშვნელობებისთვის.

ქვემოთ ცხრილში მითითებულია განსხვავებები:

|       | იტერატორები | ასინქრონული იტერატორები |
|-------|-----------|-----------------|
| ობიექტის მეთოდი იტერაციის გადასაცემად | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()` რასაც აბრუნებს              | any value         | `Promise`  |
| იტერაციისთვის გამოყენებული ციკლი                          | `for..of`         | `for await..of` |

````warn header="გაშლის ოპერატორს `...` ასინქრონულ სიტუაციაში ვერ გამოვიყენებთ"
Features that require regular, synchronous iterators, don't work with asynchronous ones.
სინქრონული იტერატორების თვისებებს ასინქრონულებთან ვერ გამოვიყენებთ.

მაგალითად, გაშლის ოპერატორი არ იმუშავებს:
```js
alert( [...range] ); // Error, no Symbol.iterator
```

ანუ ბუნებრივია, რადგან ის ცდილობს მოძებნოს `Symbol.iterator` და არა `Symbol.asyncIterator`. 

იგივე სიტუაციაა `for..of`-თვის: `await`-ის გარეშე მხოლოდ `Symbol.iterator`-თან შეგვიძლია გამოვიყენოთ.
````

## გავიხსენოთ გენერატორები

მოდი გავიხსენოთ გენერატორები, რადგან ისინი იტერაციის კოდის მოკლედ დაწერის საშუალებას გვაძლევენ. ხშირად, როცა გვინდა რაიმე იტერირებადის შექმნა გვინდა, გამოვიყენებთ გენერატორებს.

სიმარტივისთვის, დეტალები რომ გამოვტოვოთ, ისინი არიან "ფუნქციები, რომლებიც აგენერირებენ (აბრუნებენ, yield) მნიშვნელობებს". უფრო დეტალურად აღწერილია თავში [გენერატორები](info:generators).

გენერატორის სინტაქსი იწყება `function*`-ით (ყურადღება მიაქციეთ ვარსკვლავს) და იყენებს `yield`-ის მნიშვნელობის დასაგენერირებლად, და იტერაციისთვის შეგვიძლია გამოვიყენოთ `for..of` ციკლი.

ეს მაგალითი აგენერირებს მიმდევრობას `start`-დან `end`-მდე:

```js run
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for(let value of generateSequence(1, 5)) {
  alert(value); // 1, შემდეგ 2, შემდეგ 3, შემდეგ 4, შემდეგ 5
}
```

როგორც უკვე ვიცით, იმისათვის რომ ობიექტი გავხადოთ იტერირებადი, უნდა გამოვიყენოთ `Symbol.iterator`.

```js
let range = {
  from: 1,
  to: 5,
*!*
  [Symbol.iterator]() {
    return <ობიექტი `next` მეთოდით რომ დიაპაზონზე იტერირებადი გავხადოთ>
  }
*/!*
}
```

ზოგადად `Symbol.iterator`-ს წერენ ისე რომ გენერატორი დააბრუნოს, როგორც ხედავთ კოდს უფრო მოკლეს ხდის:

```js run
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // [Symbol.iterator]: function*() -ის შემოკლებული ვერსია
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for(let value of range) {
  alert(value); // 1, შემდეგ 2, შემდეგ 3, შემდეგ 4, შემდეგ 5
}
```

უფრო მეტი დეტალისთვის წაიკითხეთ თავი [გენერატორებზე](info:generators).

ჩვეულებრიც გენერატორებში ჩვენ ვერ გამოვიყენებთ `await`-ს. `for..of`-ის მოთხოვნაა რომ ყველა მნიშვნელობა სინქრონულად დაუბრუნდეს.

მაგრამ, იქნებ გვინდა რომ ასინქრონულად დავაგენერიროთ მნიშვნელობები? მაგალითად, ქსელის რექუესთიდან.

იმისათვის, რომ ამას მივაღწიოთ, მოდი გადავიდეთ ასინქრონულ გენერატორებზე.

## ასინქრონული გენერატორები (როგორც იქნა)

პრაქტიკაში, როცა გვინდა რომ ობიექტმა ასინქრონულად დააგენერიროს მნიშვნელობების მიმდევრობა, შეგვიძლია გამოვიყენოთ ასინქრონული გენერატორი.

სინტაქსი მარტივია: `function*`-ის წინ დავწეროთ `async`, რაც შექმნის ასინქრონულ გენერატორს.

და შემდეგ იტერაციის გამოვიყენოთ `for await (...)` ასე:

```js run
*!*async*/!* function* generateSequence(start, end) {

  for (let i = start; i <= end; i++) {

*!*
    // ჩემი კაი, await-ის გამოყენება შეგვიძლია!
    await new Promise(resolve => setTimeout(resolve, 1000));
*/!*

    yield i;
  }

}

(async () => {

  let generator = generateSequence(1, 5);
  for *!*await*/!* (let value of generator) {
    alert(value); // 1, შემდეგ 2, შემდეგ 3, შემდეგ 4, შემდეგ 5 (მათ შორის შეფერხებებით)
  }

})();
```

ვინაიდან გენერატორი ასინქრონულია, შიგნით შეგვიძლია გამოვიყენოთ `await`, ვიმოქმედოთ ფრომისებზე, ქსელში რექუესთები გავუშვათ და ა.შ.

````smart header="შინაგანი განსხვავება"
ტექნიკურად, თუ მაგარი ტიპი ხარ, რომელსაც ახსოვს დეტალები გენერატორებზე, შინაგანად არის რაღაც განსხვავება.

ასინქრონული გენერატორებისთვის, `generator.next()` მეთოდი ასინქრონულია, გვიბრუნებს ფრომისებს.

ჩვეულებრივ გენერატორში, მნიშვნელობების დასათრევად `result = generator.next()`-ს ვიყენებთ. ასინქრონულ გენერატორში, წინ უნდა დავუმატოთ `await`:

```js
result = await generator.next(); // result = {value: ..., done: true/false}
```
ამიტომაცაა რომ ასინქრონული გენერატორებისთვის ვიყენებთ for await...if`.
````

### ასინქრონულად იტერირებადი დიაპაზონი

ჩვეულებრივი გენერატორები შეგვიძლია გამოვიყენოთ როგორც `Symbol.iterator` რომ კოდი უფრო შევამოკლოთ.

შესაბამისად, ასინქრონული გენერატორები, ასინქრონული იტერაციისთვის, შეგვიძლია გამოვიყენოთ როგორც `Symbol.asyncIterator`.

მაგალითად, შეგვიძლია `range` ობიექტს დავაგენერირებინოთ მნიშვნელობები ასინქრონულად, ყოველ წამში, თუ ჩავანაცვლებთ სინქრონულ `Symbol.iterator`-ს ასინქრონულით `Symbol.asyncIterator`:

```js run
let range = {
  from: 1,
  to: 5,

  // ეს ხაზი იგივეა როგორც [Symbol.asyncIterator]: async function*() {
*!*
  async *[Symbol.asyncIterator]() {
*/!*
    for(let value = this.from; value <= this.to; value++) {

      // დავაპაუზოთ მნიშვნელობებს შორის, თითქოს რაღაცას ველოდებით
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};

(async () => {

  for *!*await*/!* (let value of range) {
    alert(value); // 1, შემდეგ 2, შემდეგ 3, შემდეგ 4, შემდეგ 5
  }

})();
```

მნიშვნელობები 1 წამის შეფერხებით გვიბრუნდება.

```smart
იდეაში, ობიექტს შეგვიძლია დავუმატოთ `Symbol.iterator` და `Symbol.asyncIterator`-ც, რომ სინქრონულად (`for..of`) და ასინქრონულად (`for await..of`) იტერირებადი იყოს.

პრაქტიკაში უცნაური იქნება, რავი მე არ მინახავს.
```

## რეალური მაგალითი: პაგინირებული მონაცემები

აქამდე ჩვეულებრივ მაგალითებს განვიხილავდით, რომ რაღაც აზრი ჩამოგვეყალიბებინა. ახლა რეალური მაგალითი განვიხილოთ.

ბევრი ონლაინ სერვისი არსებობს რომელიც პაგინირებულ მონაცემებს აბრუნებენ. მაგალითად, როდესაც მომხმარებლების სია გვინდა, რექუესთი აბრუნებს წინასწარ განსაზღვრულ რაოდენობას (მაგალითად, 100 მომხმარებელს) - "1 გვერდს", და შემდეგი გვერდის დასათრევად ახალ URL-საც გვიბრუნებს.

ეს კანონზომიერება ხშირია, არა მარტო მომხმარებლების შემთხვევაში, არამედ ზოგადადაც.

მაგალითად, GitHub საშუალებას გვაძლევს რომ კომიტები იმავენაირად, პაგინირებულად დაგვიბრუნოს:

- ჩვენ უნდა გავაგზავნოთ რექუესთი რომ დავ-`fetch`-ოთ `https://api.github.com/repos/<repo>/commits`.
- პასუხი დაგვიბრუნდება JSON-ის სახით, რომელიც 30 კომიტს შეიცავს, და ასევე შემდეგი გვერდის დასათრევად `Link` ჰედერში გვექნება ახალი URL.
- შემდეგ შეგვიძლია ის ლინკი შემდეგი რექუესთის გასაგზავნად გამოვიყენოთ, რომ კიდევ სხვა კომიტები დავითრიოთ, და ა.შ.

ჩვენი კოდისთვის, უფრო მარტივი გზა გვინდა კომიტების დასათრევად.

მოდი შევქმნათ ფუნქცია `fetchCommits(repo)` რომელიც ჩვენთვის კომიტებს დააბრუნებს, გააგზავნის რექუესთს როცა საჭიროა. და მიხედავს პაგინირებასთან დაკავშირებულ საკითხებს. ჩვენთვის ის იქნება მარტივი ასინქრონული იტერაცია `for await..of`.

ანუ ასე გამოვიყენებთ:

```js
for await (let commit of fetchCommits("username/repository")) {
  // დაამუშავე კომიტი
}
```

აი ამდაგვარი ფუნქცია, იმპლემენტირებული როგორც ასინქრონული გენერატორი:

```js
async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {
    const response = await fetch(url, { // (1)
      headers: {'User-Agent': 'Our script'}, // github მოითხოვს user-agent ჰედერს
    });

    const body = await response.json(); // (2) პასუხი არის JSON (კომიტების მასივი)

    // (3) შემდეგი გვერდის URL არის ჰედერებში, დავაექსტრაქტოთ
    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
    nextPage = nextPage?.[1];

    url = nextPage;

    for(let commit of body) { // (4) დავაბრუნოთ თითო-თითო კომიტი, სანამ გვერდის ბოლოს არ მივაღწევთ
      yield commit;
    }
  }
}
```

უფრო დეტალურად, როგორ მუშაობს:

1. ჩვენ ვიყენებთ ბრაუზერის [fetch](info:fetch) მეთოდს რომ კომიტები ჩამოვტვირთოთ.

    - საწყისი URL არის `https://api.github.com/repos/<repo>/commits`, და შემდეგი გვერდი იქნება პასუხის `Link` ჰედერში.
    - `fetch` მეთოდი, თუ დაგვჭირდა, authorization-ისა და სხვა ჰედერების მითითების საშუალებას გვაძლევს -- ჩვენს შემთხვევაში Github მოითხოვს `User-Agent`-ს.
2. კომიტები გვიბრუნდება JSON ფორმატში.
3. შემდეგი გვერდის URL-ს `Link` ჰედერში ვგებულობთ. სპეციალურ ფორმატშია და ამიტომ მაგისთვის ვიყენებთ regular expression-ს (ამას ვისწავლით თავში [Regular expressions](info:regular-expressions)).
    - შემდეგი გვერდის URL შეიძლება გამოიყურებოდეს როგორც `https://api.github.com/repositories/93253246/commits?page=2`. Github თვითონ აგენერირებს ამას.
4. და შემდეგ თითო-თითო კომიტს ვაბრუნებთ, როცა დასრულდება, შემდეგი `while(url)` იტერაცია გაეშვება, რომელიც კიდევ ერთ რექუესთს გააგზავნის.

გამოყენების მაგალითი (კონსოლში კომიტის ავტორს ბეჭდავს):

```js run
(async () => {

  let count = 0;

  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {

    console.log(commit.author.name);

    if (++count == 100) { // 100 კომიტზე გავჩერდეთ.
      break;
    }
  }

})();

// ყურადღება: თუ არ დაგავიწყდეთ fetchCommits ფუნქციის იმპლემენტაცია.
```

ზუსტად ისაა რაც გვინდოდა.

გარე სამყაროსთვის პაგინირებულ რექუესთებში რა ხდება, უჩინარია. ჩვენთვის ის მხოლოდ ასინქრონული გენერატორია რომელიც კომიტებს გვიბრუნებს.

## შეჯამება

ჩვეულებრივი იტერატორები და გენერატორები მშვენივრად მუშაობენ მონაცემებთან რომელთა დასაგენერირებლად დიდი დრო საჭირო არაა.

როდესაც ველით რომ მონაცემები ასინქრონულად მოგვივა, შეფერხებებით, შეგვიძლია ასინქრონული ნაწილები გამოვიყენოთ.

ასინქრონული და ჩვეულებრივი იტერატორების სინტაქს შორის განსხვავებები:

|       | იტერირებადი | ასინქრონულად იტერირებადი |
|-------|-----------|-----------------|
| მეთოდი, რომელიც საჭიროა ობიექტი იტერირებადი გავხადოთ | `Symbol.iterator` | `Symbol.asyncIterator` |
| `next()`-ის მნიშვნელობაა | `{value:…, done: true/false}`         | `Promise` რომელიც შემდეგ დაგვიბრუნებს `{value:…, done: true/false}`  |

ასინქრონული და ჩვეულებრივი გენერატორების სინტაქს შორის განსხვავებები:

|       | გენერატორები | ასინქრონული გენერატორები |
|-------|-----------|-----------------|
| სინტაქსი | `function*` | `async function*` |
| `next()`-ის მნიშვნელობაა | `{value:…, done: true/false}`         | `Promise` რომელიც შემდეგ დაგვიბრუნებს `{value:…, done: true/false}`  |

ვებ-დეველოპმენტში ხშირად შევხვდებით მონაცემთა სტრიმებს, როდესაც ის ნაწილ-ნაწილ მიედინება. მაგალითად, დიდი ფაილის ჩამოტვირთვის ან ატვირთვისას.

ასეთი მონაცემების დასამუშავებლად, ჩვენ შეგვიძლია გამოვიყენოთ ასინქრონული გენერატორები. აქვე ღირს იმის თქმა რომ, ზოგიერთ გარემოში, როგორიცაა ბრაუზერები, არის სხვა API სახელად Streams, რომელიც ასეთი სტრიმები დასამუშავებლად, სპეციალურ ინტერფეისს გვაწვდის, რომ გარდავქმნათ მონაცემები და ერთი სტრიმიდან მეორეს გადავცეთ (მაგალითად, ჩამოვტვირთოთ რაიმე ადგილიდან და იმწამსვე სხვაგან გავაგზავნოთ).
