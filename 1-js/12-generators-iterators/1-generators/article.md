
# გენერატორები

ჩვეულებრივი ფუნქციები მხოლოდ ერთ (ან არცერთ) მნიშვნელობას აბრუნებენ.

გენერატორებს შეუძლიათ რამდენიმე მნიშვნელობის დაბრუნება ("გაცემა", "დანებება", "yield"). ისინი [იტერატორებთან](info:iterable) კარგად მუშაობენ და მათი ერთად გამოყენება მონაცემთა სტრიმების შექმნას ამარტივებს.

## გენერატორი ფუნქციები

გენერატორის შესაქმნელად სპეციაულური სინტაქსი გვჭირდება: `function*`, ე.წ. "გენერატორი ფუნქცია".

მაგალითად:

```js
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```

გენერატორი ფუნქციები ჩვეულებრივისგან განსხვავებულად მოქმედებენ. ასეთი ფუნქციის გამოძახებისას, შიგნით არსებული კოდი არ ეშვება, არამედ აბრუნებს სპეციაულურ ობიექტს, "გენერატორ ობიექტს", რომ მართოს კოდის გაშვების პროცესი.

მაგალითისთვის:

```js run
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

// "გენერატორი ფუნქცია" ქმნის "გენერატორ ობიექტს"
let generator = generateSequence();
*!*
alert(generator); // [object Generator]
*/!*
```

ფუნქციის კოდი ჯერ არ ეშვება.

![](generateSequence-1.svg)

გენერატორის მთავარი მეთოდი არის `next()`. გამოძახებისას, კოდი უახლოეს `yield <მნიშვნელობა>`-მდე ეშვება (თუ `მნიშვნელობა`-ს არ მივუთითებთ, მაშინ `undefined`-ს დააბრუნებს). ფუნქციის კოდი პაუზდება, და გამომძახებელს `მნიშვნელობა` უბრუნდება.

`next()`-ის მნიშვნელობა ყოველთვის ობიექტია ორი მახასიათებლით:

- `value`: დაბრუნებული მნიშვნელობა.
- `done`: `true` თუ ფუნქციის კოდის გაშვება დასრულდა, სხვა შემთხვევაში `false`.

მაგალითად, ამ შემთხვევაში ვქმნით გენერატორს და პირველ ჯერზე დაბრუნებულ მნიშვნელობას ვიღებთ:

```js run
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

*!*
let one = generator.next();
*/!*

alert(JSON.stringify(one)); // {value: 1, done: false}
```

ესეიგი, ჩვენ მხოლოდ პირველი მნიშვნელობა მივიღეთ, და ახლა კი ფუნქცია მზადაა მეორე ხაზზე არსებული კოდი გაუშვას.

![](generateSequence-2.svg)

მოდი კიდევ ერთხელ გამოვიძახოთ `generator.next()`. ფუნქცია აგრძელებს კოდის გაშვებას და აბრუნებს შემდეგ `yield`-ს:

```js
let two = generator.next();

alert(JSON.stringify(two)); // {value: 2, done: false}
```

![](generateSequence-3.svg)

და, თუ ახლა უკვე მესამეჯერაც გამოვიძახებთ, მაშინ `return`-ს მივაღწევთ, რაც ფუნქციის გამოძახებას ამთავრებს:

```js
let three = generator.next();

alert(JSON.stringify(three)); // {value: 3, *!*done: true*/!*}
```

![](generateSequence-4.svg)

როგორც საბოლოო შედეგიდან - `done:true` და `value:3` ჩანს, ახლა უკვე გენერატორი დასრულებულია.

ხელახლა `generator.next()`-ის გამოძახებას აზრი არა აქვს. თუ მაინც გამოვიძახებთ, ყოველჯერზე იმავე ობიექტს დაგვიბრუნებს: `{done: true}`.

```smart header="`function* f(…)`or`function *f(…)`?"
ორივე სინტაქსი სამართლიანია.

მაგრამ ზოგადად პირველი სინტაქსი სჯობს, რადგან ვარსკვლავი `*` ხაზს უსვამს რომ ის გენერატორი ფუნქციაა, ანუ ის აღწერს "ბუნებას"/ტიპს და არა ფუნქციის სახელს, შესაბამისად ის ფუნქციასთან უნდა იყოს.

```

## გენერატორები იტერატორები არიან

`next()` მეთოდი მიგვანიშნებს იმაზე, რომ გენერატორები არიან [იტერატორები](info:iterable).

ჩვენ შეგვიძლია მათ მნიშვნელობებს `for..of`-ში გადავუყვეთ:

```js run
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, შემდეგ 2
}
````

ალბათ, უფრო ლამაზად გამოიყურება ვიდრე `next().value`-ს გამოძახება.

...მაგრამ, დაიმახსოვრეთ: წინა მაგალითი გვიჩვენებს `1`-ს, შემდეგ `2`-ს, და მორჩა. `3`-ს აღარ გვიჩვენებს!

ეს იმიტომ ხდება რომ `for..of` იტერაცია აიგნორებს ბოლო `value`-ს, როდესაც `done: true`. ანუ, თუ გვინდა რომ ყველა მნიშვნელობა დაგვიბრუნდეს `for..of`-ით, მაშინ უნდა გამოვიყენოთ `yield`:

```js run
function* generateSequence() {
  yield 1;
  yield 2;
*!*
  yield 3;
*/!*
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, შემდეგ 2, შემდეგ 3
}
```

ვინაიდან გენერატორები არიან იტერატორები, ჩვენ შეგვიძლია იტერატორების ყველა მახასიათებელი მეთოდები გამოვიყენოთ, მაგალითად, გაშლის ოპერატორი (the spread syntax) `...`:

```js run
function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let sequence = [0, ...generateSequence()];

alert(sequence); // 0, 1, 2, 3
```

ზემოთ მოცემულ კოდში, `...generateSequence()` იტერირებად გენერატორ ობიექტს ელემენტების მასივად გარდაქმნის (გაშლის ოპერატორზე მეტი ინფორმაციისთვის წაიკითხეთ [](info:rest-parameters-spread#spread-syntax))

## გენერატორების იტერატორებად გამოყენება

წინა თავში, [იტერატორები](info:iterable), ჩვენ შევქმენით იტერატორი `range` ობიექტი, რომელიც აბრუნებს მნიშვნელობებს `from..to`.

მოდი გავიხსენოთ წინა კოდი:

```js run
let range = {
  from: 1,
  to: 5,

  // for..of ამ მეთოდს ერთხელ გამოიძახებს დასაწყისში
  [Symbol.iterator]() {
    // ...ის აბრუნებს იტერატორ ობიექტს:
    // ამის შემდეგ, for..of მოქმედებს მხოლოდ მაგ ობიექტზე, სთხოვს შემდეგი მნიშვნელობების დაბრუნებას
    return {
      current: this.from,
      last: this.to,

      // for..of ციკლი next()-ს ყოველ იტერაციაზე გამოიძახებს
      next() {
        // უნდა დააბრუნოს ობიექტი { done: ..., value: ... }
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      },
    };
  },
};

// იტერაცია `range`-ზე აბრუნებს რიცხვებს `range.from`-დან `range.to`-მდე
alert([...range]); // 1,2,3,4,5
```

ჩვენ შეგვიძლია გენერატორი ფუნქცია გამოვიყენოთ იტერაციისთვის, როგორც `Symbol.iterator`.

ქვემოთ მოცემული `range` უფრო კომპაქტურია:

```js run
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() {
    // [Symbol.iterator]: function*() -ის შემოკლებული ვერსია
    for (let value = this.from; value <= this.to; value++) {
      yield value;
    }
  },
};

alert([...range]); // 1,2,3,4,5
```

ზემოთ მოცემული მაგალითი ჭეშმარიტია, რადგან `range[Symbol.iterator]()` ახლა აბრუნებს გენერატორს, და გენერატორის მეთოდები ზუსტად ისაა რასაც `for..of` მოელის:

- მას აქვს `.next()` მეთოდი
- რომელიც აბრუნებს ობიექტს `{value: ..., done: true/false}`

ეს რა თქმა უნდა დამთხვევა არაა. გენერატორები ჯავასკრიპტში სწორედ მაგ მიზეზით დაამატეს, რომ იტერატორები უფრო მარტივად დაეწერათ.

გენერატორით დაწერლი ვერსია, იტერატორით დაწერილ `range` ვერსიასთან შედარებით, უფრო ლაკონურია და რა თქმა უნდა იმავე ფუნქციას ასრულებს.

```smart header="გენერატორებს მნიშვნელობების გენერირება სამუდამოდ შეუძლიათ"
წინა მაგალითებში ჩვენ სასრული მიმდევრობა დავაგენერირეთ, მაგრამ ჩვენ შეგვიძლია ისეთი გენერატორი დავწეროთ, რომელიც მნიშვნელობებს უსასრულოდ დააბრუნებს. მაგალითად, ფსეუდო-რანდომი რიცხვების უსასრულო მიმდევრობა.

რა თქმა უნდა, ამისათვის `break` (ან `return`) დაგვჭირდება `for..of`-ში. რომ უსასრულო ციკლი თავიდა ავირიდოთ.
```

## გენერატორების კომპოზიცია

გენერატორების კომპოზიცია გენერატორის მახასიათებელი თვისებაა, რომელიც გენერატორების ერთმანეთში "ჩაშენების" საშუალებას გვაძლევს.

მაგალითად, გვაქვს ფუნქცია რომელიც აგენერირებს რიცხვების მიმდევრობას:

```js
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}
```

ახლა კი, ჩვენ გვინდა ის გენერატორი გამოვიყენოთ უფრო კომპლექსური მიმდევრობის შესაქმნელად:

- ჯერ, ციფრები `0..9` (ქარაქტერის კოდები 48..57),
- შემდეგ, დიდ-ასოებიანი ლათინური ანბანი `A..Z` (ქარაქტერის კოდები 65..90)
- და ბოლოს, პატარა-ასოებიანი ლათინური ანბანი `a..z` (ქარაქტერის კოდები 97..122)

ჩვენ შეგვიძლია ეს მიმდევრობა გამოვიყენოთ, მაგალითად, შევქმნათ პაროლი სხვადასხვა ქარაქტერების არჩევით (შეგვიძლია ასევე სინტაქსის ქარაქტერები დავამატოთ), მაგრამ მოდი ჯერ ზემო ვარიანტი დავაგენერიროთ.

ჩვეულებრივ ფუნქციაში, იმისათვის რომ რამდენიმე სხვადასხვა ფუნქციის მნიშვნელობა გავაერთიანოთ, ჩვენ მათ ვიძახებთ,  ვინახავთ დაბრუნებულ მნიშვნელობებს და ბოლოს ვაერთიანებთ.

გენერატორებისთვის არის სპეციაულური სინტაქსი `yield*`, რომელიც გენერატორების ერთმანეთში "ჩაშენების" საშუალებას გვაძლევს.

გენერატორის საბოლოო ვერსია:

```js run
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generatePasswordCodes() {

*!*
  // 0..9
  yield* generateSequence(48, 57);

  // A..Z
  yield* generateSequence(65, 90);

  // a..z
  yield* generateSequence(97, 122);
*/!*

}

let str = '';

for(let code of generatePasswordCodes()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
```

`yield*` _ანდობს_ კოდის გაშვებას სხვა გენერატორს. ანუ, `yield* gen` იტერირებს გენერატორ `gen`-ზე და მის მიერ დაბრუნებულ მნიშვნელობას გადასცემს გარე სამყაროს, გამომძახებელს, თითქოს მთავარმა გენერატორმა დააბრუნა მნიშვნელობა.

ზუსტად იმავე შედეგს მივიღებდით თუ ჩაშენებული გენერატორის კოდს პირდაპირ დავწერდით:

```js run
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

*!*
  // yield* generateSequence(48, 57);
  for (let i = 48; i <= 57; i++) yield i;

  // yield* generateSequence(65, 90);
  for (let i = 65; i <= 90; i++) yield i;

  // yield* generateSequence(97, 122);
  for (let i = 97; i <= 122; i++) yield i;
*/!*

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
```

გენერატორების კომპოზიცია ბუნებრივი გზაა იმისათვის რომ ერთი გენერატორის "დინება" მეორეში გამოვიყენოთ. ის არ იყენებს დამატებით მეხსიერებას რომ შუამავალი შედეგები შევინახოთ.

## "yield" არის ორმხრივი ქუჩა

ამ მომენტამდე, გენერატორები დაახლოებით იგივეა რაც იტერირებადი ობიექტები, სპეციაულური სინტაქსით მნიშვნელობის დასაგენერირებლად. მაგრამ სინამდვილეში, გენერატორები უფრო მძლავრები და მოქნილები არიან.

`yield` არის "ორმხრივი ქუჩა": ის არამარტო უბრუნებს მნიშვნელობას გამომძახებელს, არამედ გადასცემს გამომძახებლის მნიშვნელობას გენერატორს.

ამისათვის საჭიროა გამოვიძახოთ `generator.next(arg)`. `arg` გახდება `yield`-ის შედეგი.

მაგალითად:

```js run
function* gen() {
*!*
  // გადავცეთ კითვის ნიშანი გამომძახებელს და დაველოდოთ პასუხს
  let result = yield "2 + 2 = ?"; // (*)
*/!*

  alert(result);
}

let generator = gen();

let question = generator.next().value; // <-- yield აბრუნებს მნიშვნელობას

generator.next(4); // --> გადავცეთ მნიშვნელობა გენერატორს
```

![](genYield2.svg)

1. `generator.next()`-ის პირველი გამოძახება ყოველთვის არგუმენტის გარეშეა (არგუმენტი დაიგნორდება თუ გადავცემთ). კოდის გაშვების შემდეგ აბრუნებს პირველ მნიშვნელობას `yield "2+2=?"`. ამ დროისთვის გენერატორის კოდი პაუზდება `(*)` ხაზზე.
2. შემდეგ, როგორც სურათზე ჩანს, `yield`-ის მნიშვნელობას ვანიჭებთ `question` ცვლადს.
3. და ბოლოს, `generator.next(4)`, გენერატორი აგრძელებს კოდის გაშვებას, და `4` იქნება `result`-ის საბოლოო მნიშვნელობა: `let result = 4`.

არაა სავალდებულო, რომ `next(4)` ეგრევე გამოვიძახოთ. რა დროც არ უნდა დაჭირდეს, გენერატორი დაელოდება.

მაგალითად:

```js
// განაახლე გენერატორი გარკვეული დროის შემდეგ
setTimeout(() => generator.next(4), 1000);
```

როგორც ხედავთ, ჩვეულებრივი ფუნქციისგან განსხვავებით, გენერატორსა და გამომძახებელს ერთმანეთში შეუძლიათ მნიშვნელობების გაცვლა `next/yield`-ის გამოყენებით.

უკეთ რომ გავიგოთ, განვიხილოთ კიდევ ერთი მაგალითი:

```js run
function* gen() {
  let ask1 = yield "2 + 2 = ?";

  alert(ask1); // 4

  let ask2 = yield "3 * 3 = ?";

  alert(ask2); // 9
}

let generator = gen();

alert(generator.next().value); // "2 + 2 = ?"

alert(generator.next(4).value); // "3 * 3 = ?"

alert(generator.next(9).done); // true
```

კოდის მოქმედების სურათი:

![](genYield2-2.svg)

1. პირველი `.next()` იწყებს გაშვებას... ის აღწევს პირველ `yield`.
2. შედეგი უბრუნდება გამომძახებელს.
3. მეორე `.next(4)` გადასცემს `4`-ს როგორც პირველი `yield`-ის მნიშვნელობას და განაგრძობს კოდის გაშვებას.
4. ...აღწევს მეორე `yield`-ს, რომელიც დაბრუნებული მნიშვნელობა იქნება.
5. მესამე  `.next(9)` გადასცემს `9`-ს როგორც მეორე `yield`-ის მნიშვნელობას და განაგრძობს კოდის გაშვებას, აღწევს ფუნქციის ბოლოში, და შესაბამისად `done: true`. 

"პინგ-პონგივითაა". `next(value)`-ის თითოეული გამოძახება (პირველის გარდა) გადასცემს მნიშვნელობას გენერატორს, რომელიც გახდება ახლანდელი `yield`-ის მნიშვნელობა, და აბრუნებს შემდეგი `yield`-ის მნიშვნელობას.

## generator.throw

როგორც ხედავთ, გამომძახებელს შეუძლია გადასცეს მნიშვნელობა გენერატორს, როგორც `yield`-ის მნიშვნელობა.

...მაგრამ ჩვენ ასევე შეგვიძლია "შევქმნათ" (ვისროლოთ, გამოვაგდოთ) ერორი, როგორც მნიშვნელობა. ეს შესაძლებელია, რადგან ერორი რაღაც არსით შედეგია.

იმისათვის რომ ერორი გადავცეთ `yield`-ს, საჭიროა გამოვიძახოთ `generator.throw(err)`. ამ შემთხვევაში, `err`-ს გამოაგდებს იმ ხაზზე სადაც `yield`-ია.

მაგალითად, ამ შემთხვევაში გვაქვს ერორი:

```js run
function* gen() {
  try {
    let result = yield "2 + 2 = ?"; // (1)

    alert("კოდი აქამდე ვერ მიაღწევს, რადგან მანამდე ექსეფშენი გამოვარდება");
  } catch(e) {
    alert(e); // გვიჩვენებს ერორს
  }
}

let generator = gen();

let question = generator.next().value;

*!*
generator.throw(new Error("ო, ღმერთო ჩემო.")); // (2)
*/!*
```

ერორი, რომელიც მეორე `(2)` ხაზზე, გენერატორში, ვისროლეთ, გამოიწვევს ექსეფშენს პირველ `(1)` ხაზზე, სადაც `yield`-ია. ზემო მაგალითში, `try..catch` დაიჭერს მაგ ექსეფშენს და გვაჩვენებს.

თუ არ დავიჭერთ, მაშინ, როგორც სხვა ექსეფშენი, "ამოვარდება" გენერატორის კოდიდან და კოდს დაგვიქრაშავს.

თუ არადა, შეგვიძლია "ჩვენით" დავიჭიროთ ექსეფშენი.

```js run
function* generate() {
  let result = yield "2 + 2 = ?"; // აქ ერორი გვაქვს
}

let generator = generate();

let question = generator.next().value;

*!*
try {
  generator.throw(new Error("ო, ღმერთო ჩემო."));
} catch(e) {
  alert(e); // გვიჩვენებს ერორს
}
*/!*
```

და თუ აქაც არ დავიჭირეთ ერორი, მაშინ, იგივე სიტუაცია გვექნება და დაგვიქრაშავს კოდს.

<<<<<<< HEAD
## შეჯამება
=======
## generator.return

`generator.return(value)` finishes the generator execution and return the given `value`.

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();

g.next();        // { value: 1, done: false }
g.return('foo'); // { value: "foo", done: true }
g.next();        // { value: undefined, done: true }
```

If we again use `generator.return()` in a completed generator, it will return that value again ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)).

Often we don't use it, as most of time we want to get all returning values, but it can be useful when we want to stop generator in a specific condition.

## Summary
>>>>>>> 4d01fc20d4d82358e61518a31efe80dec9bb2602

- გენერატორები იქმნება გენერატორი ფუნქციებით `function* f(…) {…}`.
- (მხოლოდ) გენერატორის შიგნით არსებობს `yield` ოპერატორი.
- გამომძახებელსა და გენერატორს შეუძლიათ მნიშვნელობების გაცვლა `next/yield`-ის გამოყენებით.

თანამედროვე ჯავასკრიპტში, გენერატორებს იშვიათად შევხდებით. მაგრამ ზოგჯერ გამოსადეგია, რადგან ფუნქციის უნარი - გაცვალოს მონაცამები გამომძახებელთან კოდის გაშვების დროს, იშვიათია. და რა თქმა უნდა, იტერირებადი ობიექტების შესაქმნელად კარგი ვარიანტია.

შემდეგ თავში, ჩვენ ვისწავლით `async` გენერატორებს, რომლებიც გამოიყენება ასინქრონულად დაგენერირებული მონაცემების სტრიმების წასაკითხად (მაგალითად, paginated fetches over a network) `for await ... of` ციკლში.

ვებ-პროგრამირებაში ჩვენ ხშირად ვმოქმედებთ სტრიმებთან, და შესაბამისად, გენერატორების გამოყენების კიდევ ერთი არედ ითვლება.
